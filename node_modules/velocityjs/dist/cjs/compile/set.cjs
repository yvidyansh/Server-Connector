"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const utils = require("../utils.cjs");
const baseCompile = require("./base-compile.cjs");
class SetValue extends baseCompile.Compile {
  /**
   * get variable from context, if run in block, return local context, else return global context
   */
  getContext(idName) {
    const local = this.local;
    for (const condition of this.conditions) {
      if (local[condition].hasOwnProperty(idName)) {
        return local[condition];
      }
    }
    return this.context;
  }
  /**
   * parse #set
   */
  setValue(ast) {
    var _a, _b;
    const ref = ast.equal[0];
    let context = this.getContext(ref.id);
    if (this.contextId && this.contextId.indexOf("macro:") === 0) {
      context = this.context;
    }
    const valAst = ast.equal[1];
    let val;
    if (valAst.type === "math") {
      val = this.getExpression(valAst);
    } else {
      val = (_b = (_a = this.config).valueMapper) == null ? void 0 : _b.call(_a, this.getLiteral(ast.equal[1]));
    }
    if (!ref.path) {
      context[ref.id] = val;
      return;
    }
    let baseRef = context[ref.id];
    if (typeof baseRef !== "object") {
      baseRef = {};
    }
    context[ref.id] = baseRef;
    const len = ref.path ? ref.path.length : 0;
    ref.path.some((exp, i) => {
      const isEnd = len === i + 1;
      let key;
      if (exp.type === "property") {
        key = exp.id;
      } else if (exp.type === "index" && exp.id) {
        key = String(this.getLiteral(exp.id));
      } else {
        key = "";
      }
      if (isEnd) {
        baseRef[key] = val;
        return true;
      }
      baseRef = baseRef[key];
      if (baseRef === void 0) {
        return true;
      }
      return false;
    });
  }
}
utils.applyMixins(baseCompile.Compile, [SetValue]);
exports.SetValue = SetValue;
