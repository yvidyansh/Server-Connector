"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
function getRefText(ast) {
  var _a;
  if (ast.type === "macro_call") {
    return `#${getMethodText(ast)}`;
  }
  let ret = (ast == null ? void 0 : ast.leader) || "";
  const isFn = ast.args !== void 0;
  if (ast.isWraped) ret += "{";
  if (isFn) {
    ret += getMethodText(ast);
  } else {
    ret += ast.id;
  }
  (_a = ast.path) == null ? void 0 : _a.forEach((ref) => {
    if (ref.type === "method") {
      ret += "." + getMethodText(ref);
      return;
    }
    if (ref.type === "index") {
      let text = "";
      const id = ref.id;
      if (id.type === "integer") {
        text = "" + id.value;
      } else if (id.type === "string") {
        const sign = id.isEval ? '"' : "'";
        text = sign + id.value + sign;
      } else {
        text = getRefText(id);
      }
      ret += "[" + text + "]";
    }
    if (ref.type === "property") {
      ret += "." + ref.id;
    }
  });
  if (ast.isWraped) ret += "}";
  return ret;
}
function getMethodText(ref) {
  const args = (ref.args || []).map((arg) => getLiteral(arg));
  return ref.id + "(" + args.join(",") + ")";
}
function getLiteral(ast) {
  let ret = "";
  switch (ast.type) {
    case "string": {
      const sign = ast.isEval ? '"' : "'";
      ret = sign + ast.value + sign;
      break;
    }
    case "integer":
    case "runt":
    case "bool": {
      ret = ast.value + "";
      break;
    }
    case "array": {
      ret = "[";
      ret += ast.value.map((arg) => {
        if (typeof arg === "string" || typeof arg === "number") {
          return String(arg);
        }
        return getLiteral(arg);
      }).join(", ");
      ret += "]";
      break;
    }
    // map handle?
    default:
      ret = getRefText(ast);
  }
  return ret;
}
exports.getRefText = getRefText;
