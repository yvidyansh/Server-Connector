"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const index = require("./parse/index.cjs");
const blockTypes = {
  if: true,
  foreach: true,
  macro: true,
  noescape: true,
  define: true,
  macro_body: true
};
let customBlocks = {};
const TRIM_REG = /^[ \t]*\n/;
const parse = (str, blocks, ignoreSpace = true) => {
  const asts = index.parse(str);
  customBlocks = blocks ?? {};
  if (ignoreSpace) {
    asts.forEach((ast, i) => {
      if (typeof ast === "string") {
        return;
      }
      if (!["references", "raw"].includes(ast.type)) {
        const _ast = asts[i + 1];
        if (typeof _ast === "string" && TRIM_REG.test(_ast)) {
          asts[i + 1] = _ast.replace(TRIM_REG, "");
        }
      }
    });
  }
  const [ret] = makeLevel(asts);
  return ret;
};
function makeLevel(block, index2 = 0) {
  const len = block.length;
  const ret = [];
  let ignore = index2 - 1;
  for (let i = index2; i < len; i++) {
    if (i <= ignore) continue;
    const ast = block[i];
    const isString = typeof ast === "string";
    const type = !isString ? ast.type : "";
    let isBlockType = blockTypes[type];
    if (!isString && type === "macro_call" && customBlocks[ast.id]) {
      isBlockType = true;
      ast.type = ast.id;
      ast.id = "";
    }
    if (!isBlockType && type !== "end") {
      ret.push(ast);
      continue;
    }
    if (type === "end") {
      return [ret, i];
    }
    const [nest, current] = makeLevel(block, i + 1);
    ignore = current;
    nest.unshift(block[i]);
    ret.push(nest);
  }
  return [ret, 0];
}
exports.parse = parse;
